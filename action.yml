name: "PR Comment Template"
description: "Post standard, templated comments on Pull Requests (header/body/footer)."
author: "Ricardo Malnati"

branding:
  icon: "message-circle"
  color: "purple"

inputs:
  token:
    description: "GitHub token (e.g., secrets.GITHUB_TOKEN)"
    required: true
  pr_number:
    description: "Pull Request number to comment on"
    required: true
  header_actor:
    description: "Message author (e.g., github.actor)"
    required: true
  header_title:
    description: "Comment title"
    required: true
  header_subject:
    description: "Comment subject"
    required: true
  body_message:
    description: "Main message body (Markdown)"
    required: true
  body_scope:
    description: "Scope bullets (Markdown list)"
    required: false
    default: ""
  body_todo:
    description: "TODO / pending actions (Markdown list)"
    required: false
    default: ""
  footer_result:
    description: "Result summary"
    required: false
    default: ""
  footer_advise:
    description: "Advice / next steps"
    required: false
    default: ""

outputs:
  comment_body:
    description: "Final comment body in Markdown"
    value: ${{ steps.assemble_markdown.outputs.markdown }}

runs:
  using: "composite"
  steps:
    # ------------------------------------------------------------------
    # STEP 1: Formatar Bloco de Escopo
    # Responsabilidade: Verificar input e gerar HTML/Markdown específico
    # ------------------------------------------------------------------
    - id: fmt_scope
      shell: bash
      env:
        RAW_SCOPE: ${{ inputs.body_scope }}
      run: |
        set -euo pipefail
        
        FORMATTED=""
        if [ -n "$RAW_SCOPE" ]; then
           # Usamos printf para evitar problemas de formatação
           FORMATTED=$(printf "**Escopo:**\n%s\n" "$RAW_SCOPE")
        fi

        # Multiline output seguro
        {
          echo "block<<EOF"
          echo "$FORMATTED"
          echo "EOF"
        } >> "$GITHUB_OUTPUT"

    # ------------------------------------------------------------------
    # STEP 2: Formatar Bloco de TODO
    # Responsabilidade: Isolar lógica de pendências
    # ------------------------------------------------------------------
    - id: fmt_todo
      shell: bash
      env:
        RAW_TODO: ${{ inputs.body_todo }}
      run: |
        set -euo pipefail

        FORMATTED=""
        if [ -n "$RAW_TODO" ]; then
           FORMATTED=$(printf "**Ações pendentes:**\n%s\n" "$RAW_TODO")
        fi

        {
          echo "block<<EOF"
          echo "$FORMATTED"
          echo "EOF"
        } >> "$GITHUB_OUTPUT"

    # ------------------------------------------------------------------
    # STEP 3: Formatar Rodapé
    # Responsabilidade: Lógica condicional complexa do rodapé
    # ------------------------------------------------------------------
    - id: fmt_footer
      shell: bash
      env:
        RES: ${{ inputs.footer_result }}
        ADV: ${{ inputs.footer_advise }}
      run: |
        set -euo pipefail

        FORMATTED=""
        # Concatena para verificar se algum existe
        if [ -n "${RES}${ADV}" ]; then
          FORMATTED="---"
          
          if [ -n "$RES" ]; then
            FORMATTED="${FORMATTED}\nResultado: ${RES}"
          fi
          
          if [ -n "$ADV" ]; then
            FORMATTED="${FORMATTED}\nOrientação: ${ADV}"
          fi
        fi

        {
          echo "block<<EOF"
          echo "$FORMATTED"
          echo "EOF"
        } >> "$GITHUB_OUTPUT"

    # ------------------------------------------------------------------
    # STEP 4: Montar Markdown Final (Envsubst)
    # Responsabilidade: Ler template e substituir variáveis preparadas
    # ------------------------------------------------------------------
    - id: assemble_markdown
      shell: bash
      env:
        # Inputs diretos
        ACTOR: ${{ inputs.header_actor }}
        TITLE: ${{ inputs.header_title }}
        SUBJECT: ${{ inputs.header_subject }}
        BODY_MESSAGE: ${{ inputs.body_message }}
        # Inputs processados (outputs dos steps anteriores)
        BODY_SCOPE_BLOCK: ${{ steps.fmt_scope.outputs.block }}
        BODY_TODO_BLOCK: ${{ steps.fmt_todo.outputs.block }}
        FOOTER_BLOCK: ${{ steps.fmt_footer.outputs.block }}
        # Caminho
        TEMPLATE_PATH: ${{ github.action_path }}/templates/pr-comment.md
      run: |
        set -euo pipefail

        if [ ! -f "$TEMPLATE_PATH" ]; then
          echo "::error::Template file not found at $TEMPLATE_PATH"
          exit 1
        fi

        # Export necessário para envsubst enxergar as variáveis
        export ACTOR TITLE SUBJECT BODY_MESSAGE BODY_SCOPE_BLOCK BODY_TODO_BLOCK FOOTER_BLOCK

        MARKDOWN_CONTENT=$(envsubst < "$TEMPLATE_PATH")

        {
          echo "markdown<<EOF"
          echo "$MARKDOWN_CONTENT"
          echo "EOF"
        } >> "$GITHUB_OUTPUT"

    # ------------------------------------------------------------------
    # STEP 5: Preparar Payload JSON
    # Responsabilidade: Escapar JSON corretamente (usando jq para segurança)
    # ------------------------------------------------------------------
    - id: prepare_json
      shell: bash
      env:
        CONTENT: ${{ steps.assemble_markdown.outputs.markdown }}
      run: |
        set -euo pipefail

        # jq -R (raw input) -s (slurp) trata tudo como string única e escapa corretamente
        JSON_PAYLOAD=$(printf '%s' "$CONTENT" | jq -Rs '{body: .}')

        {
          echo "payload<<EOF"
          echo "$JSON_PAYLOAD"
          echo "EOF"
        } >> "$GITHUB_OUTPUT"

    # ------------------------------------------------------------------
    # STEP 6: Executar Request (Curl)
    # Responsabilidade: Apenas transporte de dados
    # ------------------------------------------------------------------
    - id: post_comment
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        REPO: ${{ github.repository }}
        PR_NUM: ${{ inputs.pr_number }}
        JSON_DATA: ${{ steps.prepare_json.outputs.payload }}
      run: |
        set -euo pipefail

        URL="https://api.github.com/repos/$REPO/issues/$PR_NUM/comments"
        
        echo "Posting comment to $URL..."
        
        HTTP_CODE=$(curl -sS -w "%{http_code}" -o response.json \
          -H "Authorization: Bearer $TOKEN" \
          -H "Accept: application/vnd.github+json" \
          -X POST "$URL" \
          -d "$JSON_DATA")

        if [[ "$HTTP_CODE" -lt 200 || "$HTTP_CODE" -ge 300 ]]; then
          echo "::error::Failed to post comment. HTTP Code: $HTTP_CODE"
          cat response.json
          exit 1
        else
          echo "Comment posted successfully (HTTP $HTTP_CODE)."
        fi
