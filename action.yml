# Malnati/pr-comment@v5.0.1
name: "PR Comment Template"
description: "Post standard, templated comments on Pull Requests (header/body/footer)."
author: "Ricardo Malnati"

branding:
  icon: "message-circle"
  color: "purple"

inputs:
  token:
    description: "GitHub token"
    required: true
  pr_number:
    description: "PR number"
    required: true
  header_actor:
    description: "Message author"
    required: true
  header_title:
    description: "Comment title"
    required: true
  header_subject:
    description: "Comment subject"
    required: true
  body_message:
    description: "Main message body"
    required: true
  body_scope:
    description: "Scope text"
    required: false
    default: ""
  body_todo:
    description: "TODO text"
    required: false
    default: ""
  footer_result:
    description: "Result summary"
    required: false
    default: ""
  footer_advise:
    description: "Advice / next steps"
    required: false
    default: ""
  template_path:
    description: "Path to custom Markdown template"
    required: false
    default: ""

runs:
  using: "composite"
  steps:
    # ------------------------------------------------------------------
    # STEP 1: Validar Template (Logs apenas)
    # ------------------------------------------------------------------
    - id: check_template
      shell: bash
      env:
        CUSTOM_PATH: ${{ inputs.template_path }}
        DEFAULT_PATH: ${{ github.action_path }}/templates/pr-comment.md
      run: |
        set -euo pipefail
        REQUIRED_VARS=("BODY_MESSAGE")
        FINAL_TEMPLATE="$DEFAULT_PATH"

        if [ -z "$CUSTOM_PATH" ]; then
          echo "Using default template."
        elif [ ! -f "$CUSTOM_PATH" ]; then
          echo "::warning title=Template Not Found::Arquivo '$CUSTOM_PATH' não encontrado. Usando padrão."
          FINAL_TEMPLATE="$DEFAULT_PATH"
        else
          MISSING=()
          for VAR in "${REQUIRED_VARS[@]}"; do
            if ! grep -Fq "\${$VAR}" "$CUSTOM_PATH" && ! grep -Fq "\$$VAR" "$CUSTOM_PATH"; then
               MISSING+=("$VAR")
            fi
          done

          if [ ${#MISSING[@]} -gt 0 ]; then
            MISSING_STR=$(IFS=', '; echo "${MISSING[*]}")
            echo "::warning title=Invalid Template::Template inválido. Faltam: [$MISSING_STR]. Usando padrão."
            FINAL_TEMPLATE="$DEFAULT_PATH"
          else
            echo "Template validado."
            FINAL_TEMPLATE="$CUSTOM_PATH"
          fi
        fi
        
        # Output simples (single line) não precisa de heredoc
        echo "template_file=$FINAL_TEMPLATE" >> "$GITHUB_OUTPUT"

    # ------------------------------------------------------------------
    # STEP 2: Montar Markdown Final (Usando DISCO em vez de Output)
    # ------------------------------------------------------------------
    - id: assemble_markdown
      shell: bash
      env:
        # Inputs diretos (Eliminando steps intermediários)
        ACTOR: ${{ inputs.header_actor }}
        TITLE: ${{ inputs.header_title }}
        SUBJECT: ${{ inputs.header_subject }}
        BODY_MESSAGE: ${{ inputs.body_message }}
        RAW_SCOPE: ${{ inputs.body_scope }}
        RAW_TODO: ${{ inputs.body_todo }}
        # Inputs para lógica do rodapé
        IN_RES: ${{ inputs.footer_result }}
        IN_ADV: ${{ inputs.footer_advise }}
        # Caminho do template resolvido
        TEMPLATE_PATH: ${{ steps.check_template.outputs.template_file }}
      run: |
        set -euo pipefail

        if [ ! -f "$TEMPLATE_PATH" ]; then
          echo "::error::Critical: Template path invalido."
          exit 1
        fi

        # 1. Lógica do Rodapé (Movida para cá para evitar step extra)
        FOOTER_BLOCK=""
        if [ -n "$IN_RES" ]; then
           FOOTER_BLOCK="$IN_RES"
        fi
        if [ -n "$IN_ADV" ]; then
           if [ -n "$FOOTER_BLOCK" ]; then
              FOOTER_BLOCK="${FOOTER_BLOCK}<br>${IN_ADV}"
           else
              FOOTER_BLOCK="$IN_ADV"
           fi
        fi

        # 2. Exportar variáveis para o envsubst
        export ACTOR TITLE SUBJECT BODY_MESSAGE
        export BODY_SCOPE_BLOCK="$RAW_SCOPE"
        export BODY_TODO_BLOCK="$RAW_TODO"
        export FOOTER_BLOCK="$FOOTER_BLOCK"

        # 3. Substituir e SALVAR EM DISCO (/tmp)
        # Isso evita completamente erros de EOF ou caracteres especiais no GITHUB_OUTPUT
        envsubst < "$TEMPLATE_PATH" > /tmp/final_message.md
        
        echo "Markdown gerado em /tmp/final_message.md"

    # ------------------------------------------------------------------
    # STEP 3: Preparar JSON (Lendo do DISCO)
    # ------------------------------------------------------------------
    - id: prepare_json
      shell: bash
      run: |
        set -euo pipefail
        
        # Lê o arquivo do disco e usa jq para criar o JSON seguro
        # jq --raw-input --slurp lê o arquivo todo como uma única string
        jq --raw-input --slurp '{body: .}' /tmp/final_message.md > /tmp/payload.json
        
        echo "Payload JSON gerado em /tmp/payload.json"

    # ------------------------------------------------------------------
    # STEP 4: Request (Enviando arquivo)
    # ------------------------------------------------------------------
    - id: post_comment
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        REPO: ${{ github.repository }}
        PR_NUM: ${{ inputs.pr_number }}
      run: |
        set -euo pipefail
        URL="https://api.github.com/repos/$REPO/issues/$PR_NUM/comments"
        
        # Passamos o arquivo JSON direto pro Curl com @
        HTTP_CODE=$(curl -sS -w "%{http_code}" -o response.json \
          -H "Authorization: Bearer $TOKEN" \
          -H "Accept: application/vnd.github+json" \
          -H "Content-Type: application/json" \
          -X POST "$URL" \
          -d @/tmp/payload.json)

        if [[ "$HTTP_CODE" -lt 200 || "$HTTP_CODE" -ge 300 ]]; then
          echo "::error::Failed to post comment. HTTP Code: $HTTP_CODE"
          cat response.json
          exit 1
        else
          echo "Comment posted successfully."
        fi
