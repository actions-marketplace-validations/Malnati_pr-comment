# Malnati/pr-comment@v6.0.1
name: "PR Comment Template"
description: "Post standard, templated comments on Pull Requests with Sticky mode support."
author: "Ricardo Malnati"

branding:
  icon: "message-circle"
  color: "purple"

inputs:
  token:
    description: "GitHub token"
    required: true
  pr_number:
    description: "PR number"
    required: true
  header_actor:
    description: "Message author"
    required: true
  header_title:
    description: "Comment title"
    required: true
  header_subject:
    description: "Comment subject"
    required: true
  body_message:
    description: "Main message body"
    required: true
  body_scope:
    description: "Scope text"
    required: false
    default: ""
  body_todo:
    description: "TODO text"
    required: false
    default: ""
  footer_result:
    description: "Result summary"
    required: false
    default: ""
  footer_advise:
    description: "Advice / next steps"
    required: false
    default: ""
  template_path:
    description: "Path to custom Markdown template"
    required: false
    default: ""
  message_id:
    description: "Unique ID (hidden) to enable Sticky Comments"
    required: false
    default: ""

runs:
  using: "composite"
  steps:
    # ------------------------------------------------------------------
    # STEP 1: Validar Template
    # ------------------------------------------------------------------
    - id: check_template
      shell: bash
      env:
        CUSTOM_PATH: ${{ inputs.template_path }}
        DEFAULT_PATH: ${{ github.action_path }}/templates/pr-comment.md
      run: |
        set -euo pipefail
        REQUIRED_VARS=("BODY_MESSAGE")
        FINAL_TEMPLATE="$DEFAULT_PATH"

        if [ -z "$CUSTOM_PATH" ]; then
          echo "Using default template."
        elif [ ! -f "$CUSTOM_PATH" ]; then
          echo "::warning title=Template Not Found::Arquivo '$CUSTOM_PATH' não encontrado. Usando padrão."
        else
          MISSING=()
          for VAR in "${REQUIRED_VARS[@]}"; do
            if ! grep -Fq "\${$VAR}" "$CUSTOM_PATH" && ! grep -Fq "\$$VAR" "$CUSTOM_PATH"; then
               MISSING+=("$VAR")
            fi
          done
          if [ ${#MISSING[@]} -gt 0 ]; then
            MISSING_STR=$(IFS=', '; echo "${MISSING[*]}")
            echo "::warning title=Invalid Template::Template inválido. Faltam: [$MISSING_STR]. Usando padrão."
          else
            FINAL_TEMPLATE="$CUSTOM_PATH"
          fi
        fi
        echo "template_file=$FINAL_TEMPLATE" >> "$GITHUB_OUTPUT"

    # ------------------------------------------------------------------
    # STEP 2: Montar Markdown e Injetar ID Oculto
    # ------------------------------------------------------------------
    - id: assemble_markdown
      shell: bash
      env:
        # Inputs
        ACTOR: ${{ inputs.header_actor }}
        TITLE: ${{ inputs.header_title }}
        SUBJECT: ${{ inputs.header_subject }}
        BODY_MESSAGE: ${{ inputs.body_message }}
        RAW_SCOPE: ${{ inputs.body_scope }}
        RAW_TODO: ${{ inputs.body_todo }}
        IN_RES: ${{ inputs.footer_result }}
        IN_ADV: ${{ inputs.footer_advise }}
        TEMPLATE_PATH: ${{ steps.check_template.outputs.template_file }}
        MSG_ID: ${{ inputs.message_id }}
      run: |
        set -euo pipefail

        if [ ! -f "$TEMPLATE_PATH" ]; then
          echo "::error::Critical: Template path invalido."
          exit 1
        fi

        # 1. Rodapé
        FOOTER_BLOCK=""
        if [ -n "$IN_RES" ]; then
           FOOTER_BLOCK="$IN_RES"
        fi
        if [ -n "$IN_ADV" ]; then
           if [ -n "$FOOTER_BLOCK" ]; then
              FOOTER_BLOCK="${FOOTER_BLOCK}<br>${IN_ADV}"
           else
              FOOTER_BLOCK="$IN_ADV"
           fi
        fi

        # 2. Exportar
        export ACTOR TITLE SUBJECT BODY_MESSAGE
        export BODY_SCOPE_BLOCK="$RAW_SCOPE"
        export BODY_TODO_BLOCK="$RAW_TODO"
        export FOOTER_BLOCK="$FOOTER_BLOCK"

        # 3. Renderizar template temporário
        envsubst < "$TEMPLATE_PATH" > /tmp/content_raw.md

        # 4. Injetar ID Oculto (Se existir) no TOPO do arquivo final
        if [ -n "$MSG_ID" ]; then
           echo "" > /tmp/final_message.md
           cat /tmp/content_raw.md >> /tmp/final_message.md
           echo "Sticky ID '$MSG_ID' injetado no markdown."
        else
           mv /tmp/content_raw.md /tmp/final_message.md
        fi

    # ------------------------------------------------------------------
    # STEP 3: Decidir Ação (Create vs Update)
    # ------------------------------------------------------------------
    - id: resolve_action
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        REPO: ${{ github.repository }}
        PR_NUM: ${{ inputs.pr_number }}
        MSG_ID: ${{ inputs.message_id }}
      run: |
        set -euo pipefail
        
        # Default: Criar Novo
        TARGET_URL="https://api.github.com/repos/$REPO/issues/$PR_NUM/comments"
        HTTP_METHOD="POST"
        LOG_MSG="Criando novo comentário..."

        # Se tiver ID, procura se já existe
        if [ -n "$MSG_ID" ]; then
           echo "Buscando comentário existente com ID: $MSG_ID..."
           
           # Busca comentários (limitado a 100 para performance)
           # CORREÇÃO: O jq agora busca a string exata ""
           EXISTING_ID=$(curl -s -H "Authorization: Bearer $TOKEN" \
             "https://api.github.com/repos/$REPO/issues/$PR_NUM/comments?per_page=100" \
             | jq -r ".[] | select(.body | contains(\"\")) | .id" | head -n 1)

           if [ -n "$EXISTING_ID" ] && [ "$EXISTING_ID" != "null" ]; then
              # Se achou, muda para UPDATE (PATCH)
              TARGET_URL="https://api.github.com/repos/$REPO/issues/comments/$EXISTING_ID"
              HTTP_METHOD="PATCH"
              LOG_MSG="Atualizando comentário ID $EXISTING_ID..."
           else
              LOG_MSG="Comentário anterior não encontrado. Criando novo."
           fi
        fi

        echo "url=$TARGET_URL" >> "$GITHUB_OUTPUT"
        echo "method=$HTTP_METHOD" >> "$GITHUB_OUTPUT"
        echo "log=$LOG_MSG" >> "$GITHUB_OUTPUT"

    # ------------------------------------------------------------------
    # STEP 4: Preparar JSON
    # ------------------------------------------------------------------
    - id: prepare_json
      shell: bash
      run: |
        set -euo pipefail
        jq --raw-input --slurp '{body: .}' /tmp/final_message.md > /tmp/payload.json

    # ------------------------------------------------------------------
    # STEP 5: Executar Request (Dinâmico)
    # ------------------------------------------------------------------
    - id: send_request
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        URL: ${{ steps.resolve_action.outputs.url }}
        METHOD: ${{ steps.resolve_action.outputs.method }}
        LOG: ${{ steps.resolve_action.outputs.log }}
      run: |
        set -euo pipefail
        echo "$LOG"
        
        HTTP_CODE=$(curl -sS -w "%{http_code}" -o response.json \
          -H "Authorization: Bearer $TOKEN" \
          -H "Accept: application/vnd.github+json" \
          -H "Content-Type: application/json" \
          -X "$METHOD" "$URL" \
          -d @/tmp/payload.json)

        if [[ "$HTTP_CODE" -lt 200 || "$HTTP_CODE" -ge 300 ]]; then
          echo "::error::Request Failed ($METHOD). HTTP Code: $HTTP_CODE"
          cat response.json
          exit 1
        else
          echo "Success! ($HTTP_CODE)"
        fi
