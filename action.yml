# Malnati/pr-comment@v6.1.0
name: "PR Comment Template"
description: "Post standard, templated comments on Pull Requests with Sticky mode support."
author: "Ricardo Malnati"

branding:
  icon: "message-circle"
  color: "purple"

inputs:
  token:
    description: "GitHub token"
    required: true
  pr_number:
    description: "PR number"
    required: true
  header_actor:
    description: "Message author"
    required: true
  header_title:
    description: "Comment title"
    required: true
  header_subject:
    description: "Comment subject"
    required: true
  body_message:
    description: "Main message body"
    required: true
  body_scope:
    description: "Scope text"
    required: false
    default: ""
  body_todo:
    description: "TODO text"
    required: false
    default: ""
  footer_result:
    description: "Result summary"
    required: false
    default: ""
  footer_advise:
    description: "Advice / next steps"
    required: false
    default: ""
  template_path:
    description: "Path to custom Markdown template"
    required: false
    default: ""
  message_id:
    description: "Unique ID (hidden) to enable Sticky Comments"
    required: false
    default: ""

runs:
  using: "composite"
  steps:
    # ------------------------------------------------------------------
    # STEP 0: DIAGN√ìSTICO DE INPUTS (Log Rico)
    # ------------------------------------------------------------------
    - id: debug_inputs
      shell: bash
      env:
        PR_NUM: ${{ inputs.pr_number }}
        MSG_ID: ${{ inputs.message_id }}
        TPL_PATH: ${{ inputs.template_path }}
        # Verificando presen√ßa de conte√∫do opcional
        HAS_SCOPE: ${{ inputs.body_scope }}
        HAS_TODO: ${{ inputs.body_todo }}
        HAS_RES: ${{ inputs.footer_result }}
      run: |
        echo "::group::üîç Step 0: Input Configuration Analysis"
        echo "---------------------------------------------------------------"
        echo "üéØ Target Pull Request: #$PR_NUM"
        echo "---------------------------------------------------------------"
        
        # 1. Analisa Sticky Mode
        if [ -n "$MSG_ID" ]; then
           echo "‚úÖ Sticky Mode: ENABLED"
           echo "   üîπ ID: '$MSG_ID'"
           echo "   üëâ Consequ√™ncia: A Action buscar√° um coment√°rio existente com este ID."
           echo "      - Se encontrar: Executa PATCH (Atualiza)."
           echo "      - Se n√£o encontrar: Executa POST (Cria novo)."
        else
           echo "‚ö™ Sticky Mode: DISABLED (Input 'message_id' is empty)"
           echo "   üëâ Consequ√™ncia: A Action sempre executar√° POST (Criar√° um novo coment√°rio)."
           echo "      Isso pode gerar spam se o workflow rodar m√∫ltiplas vezes."
        fi
        echo "---------------------------------------------------------------"

        # 2. Analisa Template
        if [ -n "$TPL_PATH" ]; then
           echo "üìù Template: CUSTOM"
           echo "   üîπ Path: '$TPL_PATH'"
           echo "   üëâ Consequ√™ncia: O layout ser√° renderizado usando seu arquivo."
        else
           echo "üìÑ Template: DEFAULT"
           echo "   üëâ Consequ√™ncia: Usando layout padr√£o embutido na Action."
        fi
        echo "---------------------------------------------------------------"

        # 3. Resumo de Conte√∫do
        echo "üì¶ Content Blocks:"
        [ -n "$HAS_SCOPE" ] && echo "   - Scope: Present" || echo "   - Scope: Empty (Skipped)"
        [ -n "$HAS_TODO" ]  && echo "   - Todo:  Present" || echo "   - Todo:  Empty (Skipped)"
        [ -n "$HAS_RES" ]   && echo "   - Footer: Present" || echo "   - Footer: Empty (Skipped)"
        
        echo "::endgroup::"

    # ------------------------------------------------------------------
    # STEP 0.5: VERIFICA√á√ÉO DE PERMISS√ïES (Token Probe)
    # ------------------------------------------------------------------
    - id: debug_perms
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
      run: |
        echo "::group::üîê Step 0.5: Token Permission Check"
        
        # Faz um request HEAD para checar conectividade e headers
        # O GitHub Actions TOKEN nem sempre retorna x-oauth-scopes, mas validamos a conex√£o
        RESPONSE=$(curl -s -I -w "%{http_code}" -H "Authorization: Bearer $TOKEN" https://api.github.com/rate_limit)
        HTTP_CODE=${RESPONSE: -3}
        
        echo "üì° API Connectivity Check:"
        if [ "$HTTP_CODE" == "200" ]; then
           echo "   ‚úÖ Status 200 OK - Token aceito pela API."
        else
           echo "   ‚ö†Ô∏è Status $HTTP_CODE - Token pode ser inv√°lido ou ter restri√ß√µes de rede."
        fi
        
        echo ""
        echo "üìã REQUIRED PERMISSIONS (Lembrete):"
        echo "   Para esta Action funcionar, o token deve ter:"
        echo "   1. pull-requests: write  (Para postar/editar coment√°rios)"
        echo "   2. issues: write         (Fallback em alguns repos)"
        echo "   3. contents: read        (Para ler o arquivo de template)"
        echo ""
        echo "   Se voc√™ receber erro 403 (Resource not accessible), verifique seu workflow YAML."
        echo "::endgroup::"

    # ------------------------------------------------------------------
    # STEP 1: Validar Template
    # ------------------------------------------------------------------
    - id: check_template
      shell: bash
      env:
        CUSTOM_PATH: ${{ inputs.template_path }}
        DEFAULT_PATH: ${{ github.action_path }}/templates/pr-comment.md
      run: |
        set -euo pipefail
        REQUIRED_VARS=("BODY_MESSAGE")
        FINAL_TEMPLATE="$DEFAULT_PATH"

        if [ -z "$CUSTOM_PATH" ]; then
          echo "Using default template."
        elif [ ! -f "$CUSTOM_PATH" ]; then
          echo "::warning title=Template Not Found::Arquivo '$CUSTOM_PATH' n√£o encontrado. Usando padr√£o."
        else
          MISSING=()
          for VAR in "${REQUIRED_VARS[@]}"; do
            if ! grep -Fq "\${$VAR}" "$CUSTOM_PATH" && ! grep -Fq "\$$VAR" "$CUSTOM_PATH"; then
               MISSING+=("$VAR")
            fi
          done
          if [ ${#MISSING[@]} -gt 0 ]; then
            MISSING_STR=$(IFS=', '; echo "${MISSING[*]}")
            echo "::warning title=Invalid Template::Template inv√°lido. Faltam: [$MISSING_STR]. Usando padr√£o."
          else
            FINAL_TEMPLATE="$CUSTOM_PATH"
          fi
        fi
        echo "template_file=$FINAL_TEMPLATE" >> "$GITHUB_OUTPUT"

    # ------------------------------------------------------------------
    # STEP 2: Montar Markdown e Injetar ID Oculto
    # ------------------------------------------------------------------
    - id: assemble_markdown
      shell: bash
      env:
        # Inputs
        ACTOR: ${{ inputs.header_actor }}
        TITLE: ${{ inputs.header_title }}
        SUBJECT: ${{ inputs.header_subject }}
        BODY_MESSAGE: ${{ inputs.body_message }}
        RAW_SCOPE: ${{ inputs.body_scope }}
        RAW_TODO: ${{ inputs.body_todo }}
        IN_RES: ${{ inputs.footer_result }}
        IN_ADV: ${{ inputs.footer_advise }}
        TEMPLATE_PATH: ${{ steps.check_template.outputs.template_file }}
        MSG_ID: ${{ inputs.message_id }}
      run: |
        set -euo pipefail

        if [ ! -f "$TEMPLATE_PATH" ]; then
          echo "::error::Critical: Template path invalido."
          exit 1
        fi

        # 1. Rodap√©
        FOOTER_BLOCK=""
        if [ -n "$IN_RES" ]; then
           FOOTER_BLOCK="$IN_RES"
        fi
        if [ -n "$IN_ADV" ]; then
           if [ -n "$FOOTER_BLOCK" ]; then
              FOOTER_BLOCK="${FOOTER_BLOCK}<br>${IN_ADV}"
           else
              FOOTER_BLOCK="$IN_ADV"
           fi
        fi

        # 2. Exportar
        export ACTOR TITLE SUBJECT BODY_MESSAGE
        export BODY_SCOPE_BLOCK="$RAW_SCOPE"
        export BODY_TODO_BLOCK="$RAW_TODO"
        export FOOTER_BLOCK="$FOOTER_BLOCK"

        # 3. Renderizar template tempor√°rio
        envsubst < "$TEMPLATE_PATH" > /tmp/content_raw.md

        # 4. Injetar ID Oculto (Se existir) no TOPO do arquivo final
        if [ -n "$MSG_ID" ]; then
           echo "" > /tmp/final_message.md
           cat /tmp/content_raw.md >> /tmp/final_message.md
           echo "Sticky ID '$MSG_ID' injetado no markdown."
        else
           mv /tmp/content_raw.md /tmp/final_message.md
        fi

    # ------------------------------------------------------------------
    # STEP 3: Decidir A√ß√£o (Create vs Update)
    # ------------------------------------------------------------------
    - id: resolve_action
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        REPO: ${{ github.repository }}
        PR_NUM: ${{ inputs.pr_number }}
        MSG_ID: ${{ inputs.message_id }}
      run: |
        set -euo pipefail
        
        # Default: Criar Novo
        TARGET_URL="https://api.github.com/repos/$REPO/issues/$PR_NUM/comments"
        HTTP_METHOD="POST"
        LOG_MSG="Criando novo coment√°rio..."

        # Se tiver ID, procura se j√° existe
        if [ -n "$MSG_ID" ]; then
           echo "Buscando coment√°rio existente com ID: $MSG_ID..."
           
           # Busca coment√°rios (limitado a 100 para performance)
           EXISTING_ID=$(curl -s -H "Authorization: Bearer $TOKEN" \
             "https://api.github.com/repos/$REPO/issues/$PR_NUM/comments?per_page=100" \
             | jq -r ".[] | select(.body | contains(\"\")) | .id" | head -n 1)

           if [ -n "$EXISTING_ID" ] && [ "$EXISTING_ID" != "null" ]; then
              # Se achou, muda para UPDATE (PATCH)
              TARGET_URL="https://api.github.com/repos/$REPO/issues/comments/$EXISTING_ID"
              HTTP_METHOD="PATCH"
              LOG_MSG="Atualizando coment√°rio ID $EXISTING_ID..."
           else
              LOG_MSG="Coment√°rio anterior n√£o encontrado. Criando novo."
           fi
        fi

        echo "url=$TARGET_URL" >> "$GITHUB_OUTPUT"
        echo "method=$HTTP_METHOD" >> "$GITHUB_OUTPUT"
        echo "log=$LOG_MSG" >> "$GITHUB_OUTPUT"

    # ------------------------------------------------------------------
    # STEP 4: Preparar JSON
    # ------------------------------------------------------------------
    - id: prepare_json
      shell: bash
      run: |
        set -euo pipefail
        jq --raw-input --slurp '{body: .}' /tmp/final_message.md > /tmp/payload.json

    # ------------------------------------------------------------------
    # STEP 5: Executar Request (Din√¢mico)
    # ------------------------------------------------------------------
    - id: send_request
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        URL: ${{ steps.resolve_action.outputs.url }}
        METHOD: ${{ steps.resolve_action.outputs.method }}
        LOG: ${{ steps.resolve_action.outputs.log }}
      run: |
        set -euo pipefail
        echo "$LOG"
        
        HTTP_CODE=$(curl -sS -w "%{http_code}" -o response.json \
          -H "Authorization: Bearer $TOKEN" \
          -H "Accept: application/vnd.github+json" \
          -H "Content-Type: application/json" \
          -X "$METHOD" "$URL" \
          -d @/tmp/payload.json)

        if [[ "$HTTP_CODE" -lt 200 || "$HTTP_CODE" -ge 300 ]]; then
          echo "::error::Request Failed ($METHOD). HTTP Code: $HTTP_CODE"
          cat response.json
          exit 1
        else
          echo "Success! ($HTTP_CODE)"
        fi
