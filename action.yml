# Malnati/pr-comment@v8.0.0
name: "PR Comment Pro"
description: "Posta coment√°rios padronizados e 'Sticky' em Pull Requests com ou sem template. Malnati/pr-comment@v8.0.0"
author: "Ricardo Malnati"

branding:
  icon: "message-circle"
  color: "purple"

inputs:
  token:
    description: "GitHub token (contents:read, pull-requests:write)."
    required: true
  pr_number:
    description: "Pull Request number."
    required: true
  
  template_path:
    description: "Caminho relativo para o arquivo de template Markdown."
    required: false
    default: ""

  use_raw_body:
    description: "Se 'true', ignora templates e usa o texto cru da vari√°vel de ambiente BODY_MESSAGE."
    required: false
    default: "false"
  
  message_id:
    description: "ID √∫nico (invis√≠vel) para atualizar o mesmo coment√°rio (Sticky Mode)."
    required: false
    default: ""

runs:
  using: "composite"
  steps:
  
    # ==================================================================
    # BLOCK 1: SETUP & VALIDATION
    # ==================================================================
    # 1.0 - Valida√ß√£o de Inputs B√°sicos
    - id: validate_inputs
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        PR_NUM: ${{ inputs.pr_number }}
        USE_RAW_BODY: ${{ inputs.use_raw_body }}
        TEMPLATE_PATH: ${{ inputs.template_path }}
        BODY_MESSAGE: ${{ env.BODY_MESSAGE }}
      run: |
        echo "::group::üîß Setup: Input Validation"
        if [ -z "$TOKEN" ]; then 
           echo "‚ùå Error: Token is missing."
           exit 1
        fi
        if [ -z "$PR_NUM" ]; then 
           echo "‚ùå Error: PR Number is missing."
           exit 1
        fi
        if [ "$USE_RAW_BODY" = "true" ]; then
           if [ -z "$BODY_MESSAGE" ]; then
             echo "‚ùå Error: use_raw_body=true, mas a vari√°vel de ambiente BODY_MESSAGE est√° vazia ou n√£o foi definida."
             exit 1
           fi
           echo "::warning::Flag 'use_raw_body' habilitada: o template ser√° ignorado e o coment√°rio usar√° apenas a vari√°vel de ambiente BODY_MESSAGE."
           if [ -n "$TEMPLATE_PATH" ]; then
             echo "::notice::Input 'template_path' informado, mas ser√° ignorado porque use_raw_body=true. Remova a flag para usar substitui√ß√µes via template."
           fi
        fi
        if [ -n "$TEMPLATE_PATH" ] && [ -f "$TEMPLATE_PATH" ]; then
          VARS_IN_TEMPLATE=$(grep -o '\${[A-Za-z_][A-Za-z0-9_]*}' "$TEMPLATE_PATH" | sed 's/[${}]//g' | sort -u | tr '\n' ' ')
          echo "::warning::Template com vari√°veis para envsubst detectado."
          echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
          echo "Para passar vari√°veis para a Action, use algo semelhante a:"
          echo ""
          echo "  variables: |"
          echo "            {"
          echo "              \"VAR1\": \"...\""
          echo "            }"
          echo ""
          if [ -n "$VARS_IN_TEMPLATE" ]; then
            echo "Vari√°veis presentes: $VARS_IN_TEMPLATE"
          else
            echo "Nenhuma vari√°vel \${VAR} detectada no template informado."
          fi
          echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
        fi
        echo "‚úÖ Inputs validated."
        echo "::endgroup::"
        
    # 1.1 - Verifica√ß√£o de Permiss√µes (Probe)
    - id: check_perms
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        REPO: ${{ github.repository }}
        PR_NUM: ${{ inputs.pr_number }}
      run: |
        echo "::group::üîê Setup: Permissions Probe"
        # Testa acesso de escrita (GET em endpoint de comments valida escopo)
        URL="https://api.github.com/repos/$REPO/issues/$PR_NUM/comments"
        echo "üì° Probing API: $URL"
        HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $TOKEN" "$URL")
        if [ "$HTTP_CODE" == "200" ] || [ "$HTTP_CODE" == "404" ]; then
             echo "‚úÖ API Access OK (HTTP $HTTP_CODE)."
        else
             echo "‚ö†Ô∏è API Access Warning (HTTP $HTTP_CODE)."
             echo "   Ensure the token has 'pull-requests: write'."
        fi
        echo "::endgroup::"

    # ==================================================================
    # BLOCK 2: TEMPLATE ENGINE (FILE BASED)
    # ==================================================================
    # 2.0 - Resolu√ß√£o do Arquivo de Template
    - id: resolve_template
      shell: bash
      env:
        CUSTOM_PATH: ${{ inputs.template_path }}
        DEFAULT_PATH: ${{ github.action_path }}/templates/pr-comment.md
        USE_RAW_BODY: ${{ inputs.use_raw_body }}
      run: |
        echo "::group::üìù Template: Resolution"
        TARGET_FILE="/tmp/raw_template.md"
        if [ "$USE_RAW_BODY" = "true" ]; then
           echo "üîπ Raw mode ativo: ignorando templates e usando BODY_MESSAGE como corpo do coment√°rio.";
           : > "$TARGET_FILE"
        else
           if [[ -n "$CUSTOM_PATH" && -f "$CUSTOM_PATH" ]]; then
              echo "üîπ Selected: Custom Template ($CUSTOM_PATH)"
              cp "$CUSTOM_PATH" "$TARGET_FILE"
           else
              echo "üîπ Selected: Default Template"
              if [ ! -f "$DEFAULT_PATH" ]; then
                 echo "‚ùå Critical: Default template missing at $DEFAULT_PATH"
                 exit 1
              fi
              cp "$DEFAULT_PATH" "$TARGET_FILE"
           fi
        fi
        echo "template_file=$TARGET_FILE" >> "$GITHUB_OUTPUT"
        echo "::endgroup::"

    # 2.1 - Renderiza√ß√£o e Inje√ß√£o de ID
    - id: render_template
      shell: bash
      env:
        TEMPLATE_FILE: ${{ steps.resolve_template.outputs.template_file }}
        MSG_ID: ${{ inputs.message_id }}
        USE_RAW_BODY: ${{ inputs.use_raw_body }}
      run: |
        echo "::group::üé® Template: Rendering"
        FINAL_FILE="/tmp/final_comment.md"
        if [ -n "$MSG_ID" ]; then
           echo "<!-- pr-comment-id:$MSG_ID -->" > "$FINAL_FILE"
           echo "‚úÖ Sticky ID injected: $MSG_ID"
        else
           : > "$FINAL_FILE"
        fi
        if [ "$USE_RAW_BODY" = "true" ]; then
           echo "‚ÑπÔ∏è Raw mode habilitado: usando BODY_MESSAGE como corpo completo do coment√°rio."
           printf '%s\n' "$BODY_MESSAGE" >> "$FINAL_FILE"
           echo "‚úÖ Raw comment rendered successfully (no template)."
           echo "final_file=$FINAL_FILE" >> "$GITHUB_OUTPUT"
           echo "::endgroup::"
           exit 0
        fi
        envsubst < "$TEMPLATE_FILE" >> "$FINAL_FILE"
        echo "‚úÖ Markdown rendered successfully."
        echo "final_file=$FINAL_FILE" >> "$GITHUB_OUTPUT"
        echo "::endgroup::"
        
    # ==================================================================
    # BLOCK 3: COMMENT MANAGEMENT (STICKY LOGIC)
    # ==================================================================
    # 3.0 - Busca de Coment√°rio Existente
    - id: find_comment
      if: inputs.message_id != ''
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        REPO: ${{ github.repository }}
        PR_NUM: ${{ inputs.pr_number }}
        MSG_ID: ${{ inputs.message_id }}
      run: |
        echo "::group::üïµÔ∏è Sticky Mode: Searching"
        SEARCH_STRING="pr-comment-id:$MSG_ID"
        API_URL="https://api.github.com/repos/$REPO/issues/$PR_NUM/comments?per_page=100"
        echo "üîç Searching for ID in PR comments..."
        COMMENT_ID=$(curl -s -H "Authorization: Bearer $TOKEN" "$API_URL" \
          | jq -r ".[] | select(.body | contains(\"$SEARCH_STRING\")) | .id" \
          | head -n 1)
        if [ -n "$COMMENT_ID" ] && [ "$COMMENT_ID" != "null" ]; then
           echo "‚úÖ Found existing comment ID: $COMMENT_ID"
           echo "action=UPDATE" >> "$GITHUB_OUTPUT"
           echo "comment_id=$COMMENT_ID" >> "$GITHUB_OUTPUT"
        else
           echo "‚ö™ No match found. Creating new."
           echo "action=CREATE" >> "$GITHUB_OUTPUT"
        fi
        echo "::endgroup::"

    # 3.1 - Defini√ß√£o da URL de Destino
    - id: target_setup
      shell: bash
      env:
        REPO: ${{ github.repository }}
        PR_NUM: ${{ inputs.pr_number }}
        ACTION: ${{ steps.find_comment.outputs.action }}
        COMMENT_ID: ${{ steps.find_comment.outputs.comment_id }}
      run: |
        # Define URL e M√©todo baseado na busca anterior
        if [ "$ACTION" == "UPDATE" ]; then
           URL="https://api.github.com/repos/$REPO/issues/comments/$COMMENT_ID"
           METHOD="PATCH"
        else
           URL="https://api.github.com/repos/$REPO/issues/$PR_NUM/comments"
           METHOD="POST"
        fi
        echo "url=$URL" >> "$GITHUB_OUTPUT"
        echo "method=$METHOD" >> "$GITHUB_OUTPUT"

    # ==================================================================
    # BLOCK 4: API EXECUTION
    # ==================================================================
    # 4.0 - Prepara√ß√£o do Payload
    - id: prepare_payload
      shell: bash
      env:
        FILE: ${{ steps.render_template.outputs.final_file }}
      run: |
        echo "::group::üì¶ Payload: Packaging"
        # Converte o arquivo Markdown renderizado para JSON field 'body'
        jq --raw-input --slurp '{body: .}' "$FILE" > /tmp/payload.json
        echo "‚úÖ Payload created at /tmp/payload.json"
        echo "::endgroup::"

    # 4.1 - Envio da Requisi√ß√£o
    - id: send_request
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        URL: ${{ steps.target_setup.outputs.url }}
        METHOD: ${{ steps.target_setup.outputs.method }}
      run: |
        echo "::group::üì° API: Sending Comment"
        echo "Method: $METHOD"
        echo "Target: $URL"
        HTTP_CODE=$(curl -sS -w "%{http_code}" -o response.json \
          -H "Authorization: Bearer $TOKEN" \
          -H "Accept: application/vnd.github+json" \
          -H "Content-Type: application/json" \
          -X "$METHOD" "$URL" \
          -d @/tmp/payload.json)
        if [[ "$HTTP_CODE" -lt 200 || "$HTTP_CODE" -ge 300 ]]; then
          echo "‚ùå Request Failed ($HTTP_CODE)"
          cat response.json
          exit 1
        else
          echo "‚úÖ Success ($HTTP_CODE)"
        fi
        echo "::endgroup::"
